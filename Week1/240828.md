## 오늘 배운 것
- **주요 개념**: DDL(Create, 제약조건, Key, Alter, Drop)
- **구체적인 내용**
    - RDBMS 용어 : 릴레이션, 속성, 도메인, 튜플, 카티널리티 etc...
    - 모델링
    - 정규화
    - 분산 데이터베이스
    - Table 생성 (Create)
    - Table 제약 조건
    
## 상세 학습 내용
### 1. RDMS 용어
관계형 데이터베이스 구성 용어
- 릴레이션 : 정보 저장의 기본 형태
- 속성 : 테이블의 각 열을 의미하는 것 Column, Field
- 도메인 : 속성이 가질 수 있는 값들의 집합
- 튜플 : 테이블이 한 행을 구성하는 속성들의 집합 Record, Row
- 카티널리티 : 서로 다른 테이블 사이에 대응되는 수
    - 카티널리티가 많을 수록 조회할 데이터가 많다는 의미

Key : 각 데이터 값들을에 의해 유일하게 식별할 수 있는 속성 또는 집합
- 기본키 : 후보키 중에서 릴레이션의 튜플들을 유일하게 식별할 수 있는 키
- 대체키 : 키본키를 제외한 나머지 후보키
- 왜래키 : 다른 테이블의 행을 식별할 수 있는 속성
- 후보키 : 유일성과 최소성을 만족하는 속성 또는 속성의 집합
    - 후보키가 복합키로 구성되어 있을 경우에 최소성이 만족하는지 확인해야한다.

### 2. 모델링
데이터베이스 생명 주기
기획 -> 요구사항 수집 및 분석 -> 설계 -> 구현 -> 운영 -> 감시 및 개선

모델링 : 현실세계를 일정한 표기법에 의해 표현하는 것
- 추상화 : 일정한 표기법에 의해 표기
- 단순화 : 누구나 쉽게 이해할 수 있도록 표현
- 명확화 : 애매 모호함을 제거하고 정확하게 기술

데이터 모델링은 타인이 봤을 때 데이터의 구조와 흐름을 쉽게 이해할 수 있도록 하기 위한 것이다.
상대방마다 목적이 다르기 때문에 니즈에 맞는 Diagram을 사용해야한다.

### 3. 정규화
데이터의 중복으로 인한 이상 현상 (이상현상은 데이터의 양이 많을 수록 빈번하게 일어난다.)
1. 변경 이상
2. 삽입 이상
3. 삭제 이상

**정규화**
- 제 1 정규형(1NF, First Normal Form): 한 릴레이션을 구성하는 모든 도메인이 원자값으로 구성
- 제 2 정규형(2NF, Second Normal Form): 제 1 정규형을 만족하면서 릴레이션에 존재하는 부분 함수적 종속을 제거하여 모든 속성이 기본키에 완전 함수 종속이 되도록 만들어진 정규형
- 제 3 정규형(3NF, Third Normal Form): 제 2 정규형을 만족하면서 릴레이션을 구성하는 속성들간의 이행적 종속관계를 분해하여 속성들이 비이행적 함수 종속관계 만족하도록 만들어진 정규형
- 보이스-코드(BCNF, Boyce-Codd Normal Form): 제 3 정규형을 만족하면서 릴레이션의 모든 결정자가 후보키가 되도록 하는 정규형
- 제 4 정규형(4NF, Fourth Normal Form): BCNF를 만족하면서 릴레이션에서 다치 종속 관계 를 제거한 정규형
- 제 5 정규형(5NF, Fifth Normal Form): 후보키를 통하지 않은 조인 종속(Join Dependency) 을 제거한 정규형

실무에서는 주로 3정규형까지 사용함.
정규화는 테이블을 나누는 과정으로 삽입,삭제,갱신의 성능이 향상될 수도 있다. 하지만 갱신 시에는 성능이 떨어질 수도있다.
-> 테이터베이스의 목적에 따라서 정규화 혹은 반정규화를 진행해야한다.

- 비정규형(Non-Normal Form)
	- 업무 요건의 변경에 매우 취약 - 모델의 확장성이 좋지 않음
	- 인덱스 수가 증가하고 특정 요건 조회 시 SQL이 복잡해 짐
	- Entity의 속성이 추가될 가능성이 없을 때 사용 가능
	- 속성 레벨로 관리되는 데이터의 자식 Entity를 가질 수 없음(여러 데이터가 하나 의 인스턴스에 묶여 있어 개별로 관리해야 할 하위 데이터가 있으면 관리 불가능)
- 정규형(Normal Form)
	- 업무 요건 변경이 유연. 확장성 좋음
	- 인덱스 수 감소, 특정 요건 조회 시 SQL 단순해 짐(복잡해질 수도 있음) u Entity의 속성이 추가될 가능성이 존재할 때 사용
	- 로우 레벨로 관리되는 데이터의 자식 Entity를 가질 수 있음

-> 정규화를 너무 많이 사용할 시 Join 연산의 증가로 시스템 성능이 저하될 수 있음.
-> 최근에는 기억 장치가 대용량화 되고 저렴해지면서 정규화의 중요성이 저하되고 성능이 우선시 되고 있음.

### 4. 분산 데이터베이스
정의 : 여러 곳으로 분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 잇도록 한 데이터에비스

**특징**
- 분할 투명성
- 위치 투명성
- 중복 투명성
- 장애 투명성
- 병행 투명성

장점
- 지역 자치성, 점증적 시스템 용량 확장 l 신뢰성과 가용성
- 효용성과 융통성
- 빠른 응답속도와 통신비용 절감
- 데이터의 가용성과 신뢰성 증가 l 시스템 규모의 적절한 조절
- 각지역사용자의요구수용증대

단점
- 소프트웨어 개발 비용
- 오류의 잠재성 증대
- 처리비용의 증대
- 설계,관리의 복잡성과 비용 l 불규칙한 응답 시간
- 통제의 어려움
- 데이터 무결성에 대한 위협

### 5. Table생성 (Create)
생성 예제
```sql
# 테이블 생성 예제
# 테이블 이름 : contact
# 번호 - 정수, 일련번호, 기본키
# 이름 - 변경되지 않는 한글 7자리
# 주소 - 자주 변경되는 한글 33자리 까지
# 전화번호 - 자주 변경되는데 무조건 숫자 11자리, 0으로 시작할 수 없음
# 생일 - 날짜
# 조회를 많이하고 일련번호는 1부터 데이터는 이모티콘은 입력하지 않음.

Create Table contact (
num INT AUTO_INCREMENT PRIMARY KEY,     
name varchar(21),
address char(99),
phone varchar(11),
email char(100),
birthday Date
)Engine=MYISAM auto_increment=1 DEFAULT CHARSET=utf8;
-- 데이터 변경을 주로 하는 경우에는 인덱스를 무시하는 MYISAM을 InnoDB로 설정하고
-- 이모티콘을 저장하는 경우 utf8 대신에 utf8mb4 설정
-- 한글은 UTF-8에서 3바이트로 인코딩
```

### 6. 제약조건
1. 종류
    - NOT NULL : 필수 입력
    - UNIQUE : 중복된 값을 가질 수 없음 - Null 가능
    - PRIMARY KEY : NOT NULL이고 UNIQUE인데 테이블에 1개만 설정 가능
    - CHECK : 값의 종류나 범위를 설정
    - FOREIGN KEY : 외래키 설정 - reference
        - 삭제 혹은 삽입,수정의 제약조건을 추가해야함.
    
    제약조건은 아니지만 컬럼을 설정할 때 사용할 수 있는 옵션
    
    - DEFAULT : 기본값 설정
    - AUTO_INCREMENT : 1번만 설정 가능
2. 컬럼 제약 조건과 테이블 제약 조건
    - 컬럼 제약 조건 : 컬럼을 만들 때 조건을 설정하는 것
    - 테이블 제약 조건 : 컬럼을 만들어두고 제약 조건을 설정하는 것
    
    컬럼이름 자료형 [constraint 이름] 제약조건 < 컬럼 제약 조건
    
    …….
    
    [constraint 이름] 제약조건(컬럼이름)  < 테이블 제약 조건
    
    Not Null은 컬럼 제약 조건에서만 가능
    
    PK가 단일키 일 경우 컬럼 제약 조건에 작성해도 되지만 복합키로 구성될 경우 테이블 제약 조건에서 작성해줘야한다.

### 7. 기타 DDL

테이블 구조 변경 : ALTER
- 컬럼 추가
    - ALTER TABLE 테이블 이름 ADD 컬럼 이름 자료형 제약 조건;
- 컬럼 삭제
    - ALTER TABLE 테이블 DROP 컬럼이름;
- 컬럼의 이름과 자료형 변경
    - ALTER TABLE 테이블 이름 CHANGE 컬럼이름 새로운컬럼이름 자료형;
- 컬럼의 자료형 변경
    - ALTER TABLE 테이블이름 MODIFY 컬럼이름 자료형;
- 컬럼의 위치 변경
    - ALTER TABLE 테이블이름 MODIFY COLUMN 컬럼이름 자료형 FIRST(AFTER 다른 컬럼 이름);
- 테이블 이름 수정
    - ALTER TABLE 기존테이블이름 RENAME 새로운 이름;
- 테이블 구조 확인
    - DESC 테이블이름

테이블 삭제 : DROP
테이블을 삭제할 때는 문법에 맞게 작성하고 테이블이 존재해도 실패하는 경우가 있음.
외래키가 설정된 테이블을 삭제할 경우 외래키 옵션이 없는 경우임
이런 경우에는 부모 테이블을 삭제하고 자식 테이블을 삭제해야함
외래키를 설정할 때 되도록이면 삭제에 관련된 옵션을 설정하는 것이 좋음

테이블의 데이터 삭제 : TRUNCATE TABLE 테이블이름
구조는 남아 있음

## 참고 자료
- [자료 1](https://ggangpae1.tistory.com/596)

## 배운 점 & 느낀 점
- 데이터베이스 설계 시, 서비스의 목적을 고려하여 어떤 성능을 올릴지 고민을 많이해야한다는 것을 깨달았다. 다음 프로젝트 진행 시에는 서비스 목적에 맞는 데이터베이스를 선택하고 목적에 맞도록 성능 개선을 해봐야겠다.

## 내일의 목표
- 내일의 목표는 아니지만, 데이터베이스 수업이 끝난 이후 실생활 데이터를 가지고 DB설계를 해봐야겠다.
