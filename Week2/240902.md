# 오늘 배운 것
- **주요 개념**: MongoDB CRUD
- **구체적인 내용**
    - MongoDB
    
# 상세 학습 내용
## Redis

### 1. 데이터베이스 종류 분류

- RDBMS와 NoSQL
- 디스크 기반 데이터베이스와 인메모리 데이터베이스

### 2. 인메모리 데이터베이스 (In-Memory Database)

- 데이터를 디스크에 저장하지 않고 메모리에 저장하여, 요청이 있을 때 메모리에 있는 데이터를 빠르게 반환하는 방식의 데이터베이스.
- 디스크보다 메모리가 빠르기 때문에 고속으로 콘텐츠를 제공할 수 있는 장점이 있음.

### 3. Redis (Remote Dictionary Server)

- 오픈 소스 인메모리 키-값 데이터 스토어
    - Key - Data 형태로 데이터를 저장
    - Key는 중복될 수 없으며, 동일한 Key로 데이터를 저장하면 기존 데이터가 덮어씌워짐.
    - Key는 해시(Hash)를 사용해 저장되므로 데이터 접근 속도가 항상 일정함.
- 사용 사례:
    - 캐싱(자주 사용하는 데이터를 가까운 위치에 저장)
    - 세션 관리(네트워크에서 정보를 저장하기 위한 공간)
    - Pub/Sub
        - 웹 푸시(Server-Side Event)
    - 순위표 관리
- BSD 라이선스(오픈 소스)
- C언어로 작성되었으며 다양한 프로그래밍 언어를 지원
- 현재는 Public Cloud에서도 유사 서비스를 제공함.
- 클러스터링 기능 제공 - 확장 가능
    - 복제본을 여러 개 생성해 하나로 관리하는 기능
    - 데이터베이스에서 클러스터는 데이터를 분산 저장하는 것을 의미함.
- 백업 기능 제공
    - Redis는 인메모리 DB이므로 휘발성이 있어 전원이 차단되면 데이터가 사라지지만, 백업 기능으로 디스크에 데이터를 저장해 사용할 수 있음.
- 싱글 스레드 기반
    - 이벤트 큐를 이용해 싱글 스레드로 구현
    - 여러 작업이 있을 경우 이벤트 큐에서 순서대로 작업을 보관하고, 코어 스레드가 처리함.
- 백업 방법:
    - RDB 방식
        - 스냅샷(데이터 전체의 복사본)을 이용한 백업 방식
        - 스냅샷만 복사해 붙여 넣으면 되므로 비교적 간단한 방법이지만, 스냅샷 이후에 변경된 데이터는 복원할 수 없음.
        - 최종 결과만 저장하므로 중간 과정으로 돌아갈 수 없음.
    - AOF (Append Only File) 방식
        - 변경된 작업을 기록해 복원하는 방식
        - 복원 시 데이터 손실이 거의 없으며, 과정을 저장하기 때문에 시작 값만 알면 결과를 알 수 있음.
        - 용량이 커지고 시간이 오래 걸릴 수 있음.
    - RDB 방식과 AOF 방식 모두 장단점이 있어 함께 사용함.

**Redis Sentinel Architecture**

- 고가용성과 자동 장애 조치를 위한 도구로, 하나의 마스터에 대해 여러 슬레이브를 관리함.
- 데이터는 마스터에만 저장되며, 장애 발생 시 슬레이브 중 하나가 새로운 마스터로 승격됨.
![](https://velog.velcdn.com/images/mag000225/post/8d653135-b585-40be-b3e9-6f63ff29358f/image.png)
    
**Redis Cluster Architecture**

- 대규모 분산 시스템을 구축하기 위한 도구로, 데이터를 여러 노드에 분산 저장해 성능을 확장할 수 있음.
- 각 노드는 데이터의 일부를 담당하며, 클러스터 전체에 데이터가 균형 있게 분산됨.
![](https://velog.velcdn.com/images/mag000225/post/a6f8a1a7-6e19-4abc-8d27-d9f85da5bbea/image.png)

| **특징** | **Redis Sentinel** | **Redis Cluster** |
| --- | --- | --- |
| **주요 목적** | 고가용성 보장 및 자동 장애 조치 | 데이터의 수평적 확장성과 고가용성 보장 |
| **데이터 저장 방식** | 모든 데이터가 단일 마스터 노드에 저장됨. 슬레이브 노드는 마스터 데이터를 복제 | 데이터가 여러 마스터 노드에 분산 저장됨. 각 마스터는 특정 슬롯 범위를 담당 |
| **확장성** | 제한적 (마스터-슬레이브 구조 확장) | 뛰어난 확장성 (노드 추가/제거 시 자동으로 데이터 분산) |
| **장애 조치** | Sentinel 프로세스가 마스터 노드 장애 시 슬레이브를 새로운 마스터로 승격 | 클러스터 자체가 마스터 노드 장애 시 슬레이브를 새로운 마스터로 자동 승격 |
| **데이터 분산** | 없음 (모든 데이터는 단일 마스터 노드에 저장됨) | 있음 (데이터가 16,384개의 슬롯에 분산 저장됨) |
| **복잡성** | 상대적으로 단순함 | 비교적 복잡함 (노드 간 통신, 데이터 분산 및 자동 복구 관리 필요) |
| **데이터 접근** | 마스터 노드에 직접 접근, 마스터 장애 시 자동으로 새로운 마스터로 리다이렉트됨 | 키의 슬롯에 따라 자동으로 해당 마스터 노드에 접근, 필요 시 클러스터가 올바른 노드로 리다이렉트 |
| **노드 간 통신** | 필요 없음 (Sentinel 인스턴스 간의 통신만 필요) | 필요 (노드 간 지속적인 상태 확인과 데이터 재분배를 위한 통신) |
| **일관성** | 강한 일관성 보장 | 기본적으로 최종 일관성을 보장 (일부 데이터는 장애 상황에서 최신 상태가 아닐 수 있음) |
| **사용 사례** | 고가용성 보장이 필요한 경우 (예: 작은 규모의 애플리케이션, 기본적인 고가용성 요구) | 대규모 데이터 처리 및 확장이 필요한 경우 (예: 대형 애플리케이션, 고성능 및 확장 요구) |

### 4. 설치 방법

- Public Cloud 서비스 사용
- Docker를 이용한 설치
- Redis 홈페이지에서 다운로드
- Mac: UTM 다운로드
- Windows: Virtual Box 이용

### 5. Docker에 Redis 설치

- Redis 이미지 다운로드: `docker pull redis`
- 컨테이너 생성 및 실행: `docker run —name redisDB -d -p 6379:6379 redis`
- 컨테이너 접속: `docker exec redisDB /bin/bash`
- Redis CLI 접속 도구 실행: `redis-cli`

### 6. Redis 명령어

**유효기간 설정**

- Redis는 메모리를 사용하므로 무한정 데이터를 보관할 수 없으며, 사용하지 않는 데이터는 삭제해야 함.
- 데이터를 생성한 후 유효기간을 설정할 수 있음: `Expire (Key 이름) (시간 초)`

**String: 단순히 key, value 쌍으로 데이터를 저장하는 구조**

- 저장: `set (key) (value)`
- 읽기: `get (key)`
- 삭제: `del (key)`
- 여러 개 저장 및 읽기: `mset, mget`
- 모든 키 조회: `keys *`
    - `*` 대신 패턴 적용 가능

**List: 하나의 key에 여러 value를 list로 저장하는 구조**

- 데이터 삽입: `push (key) (value)`
- 데이터 제거 후 반환: `pop (key)`
- 일정 범위의 데이터 반환: `lrange (key) (startIndex) (endIndex)`
- 데이터 개수 조회: `llen (key)`
- 데이터 삭제: `trim  (key) (startIndex) (endIndex)`
- `llen`, `lrange`를 제외하고는 `r`과 `l`을 추가해 다른 방향에서 작업 가능

**Set: 중복된 데이터를 저장하지 않는 자료구조**

- 데이터 생성 및 추가: `sadd (key) (value1, value2 …)`
- 전체 데이터 조회: `smembers (key)`
- 존재 여부 확인: `sismember (key) (value)`
- 삭제: `srem (key) (value)`
- 무작위로 값 가져오기: `spop (key) (count)`
- 무작위 조회: `srandmember (key) (count)`

**Sorted Set (ZSet): score와 value의 형태로 데이터를 저장하는 자료구조**

- `score`를 이용해 데이터를 정렬함.
- 데이터 삽입: `zadd (key1) (score1 member1 score2 member2)`
- 범위 조회: `zrange (key) (startIndex) (endIndex) (withscores)`

**Hash: field와 value의 형태로 데이터를 저장하는 자료구조**

- 저장: `hset (key) (field value)`
- 여러 field와 value 저장: `hmset (key) (field1 value1 field2 value2 …)`
- field로 value 조회: `hget (field)`, `hmget (field)`
- key에 속한 모든 field와 value 조회: `hgetall (key)`
- 전체 field 조회: `hkeys (key)`
- 전체 value 조회: `hvals (key)`

### 7. 기타

- 외부에서 접속 가능하게 설정할 때는 컨테이너 안에 `/data` 디렉토리를 생성하고 `redis.conf` 파일을 생성함.
- `bind` 옵션에 `0.0.0.0`을 설정하면 외부에서 접속 가능.
- 백업 방법:
  - RDB에 백업할 때는 redis.conf파일에 save 시간 데이터개수를 설정하면 시간 단위로 데이터개수만큼 변경되었을 때 rdb 파일에 데이터를 백업 함.
  - AOF로 백업할 때는 redis.conf파일에 save 옵션을 만들고 appendonly yes를 추가해야 함.
  - RDB 파일이나 AOF 파일은 reids에서만 읽을 수 있음.
  - disk 데이터베이스에 백업을 할 때는 프로그램을 직접 만들어서 수행.
  - 도커에서 작업할 때는 redis.conf파일을 외부에서 만든 후 도커 볼륨을 이용해서 파일을 복사해야 함.

## Linux

- 1969년 AT&T 벨 연구소에서 어셈블리어로 개발됨.
- 최초의 고급 프로그래밍 언어로 작성된 운영체제.
- 유닉스 계열의 운영체제.
- 주로 서버용 운영체제로 많이 사용됨.
- 편리한 GUI 환경 제공.

### Linux 계통도

![](https://velog.velcdn.com/images/mag000225/post/420a5839-ae72-43c1-9bb0-0f7289eb8b38/image.png)
### Linux의 구조

![](https://velog.velcdn.com/images/mag000225/post/f3b9415e-5287-4069-af25-78aa1929c47b/image.png)

### 원격 접속

- 가상 머신을 이용해 운영체제를 설치한 경우, 터미널에서 직접 명령어를 사용할 수 있지만, 호스트 운영체제에서 복사 및 붙여넣기가 안 되고 여러 명의 사용자가 동시에 사용할 수 없음.
- 이러한 경우, 원격 접속을 통해 접속하는 것이 더 효율적임.
- Mac에서 원격 접속: `ssh 계정 @ IP`

### 종료

- GUI를 설치한 경우, 오른쪽 상단의 아이콘을 클릭하고 [컴퓨터 끄기/로그아웃] - [컴퓨터 끄기]를 선택.
- 터미널이나 shell에서는 다음 명령어를 사용해 종료할 수 있음: `poweroff`, `shutdown -p now`, `halt -p`, 또는 `init()`.
    - `shutdown -p +10`: 10분 후 종료.
    - `shutdown -r 22:00`: 22시에 재부팅.
    - `shutdown -c`: 예약된 종료 취소.
    - `shutdown -k +15`: 현재 접속한 사용자에게 15분 후 종료된다는 메시지를 전송하나, 실제로는 종료되지 않음.

### 재부팅

CLI에서 다음 명령어로 재부팅 가능: `reboot`, `shutdown -r now`, `init 6`.

### 로그아웃

- 현재 사용자의 접속을 종료.
- 관리자가 시스템을 종료하면 모든 사용자의 연결이 해제됨.
- 관리자가 자신의 접속을 종료하려면 `logout`이나 `exit` 명령어를 입력하면 됨.

## 기본 명령어 사용법

- 터미널이나 SSH 등을 이용해 원격으로 접속한 후 명령어를 사용함.
- Shell: 명령어 해석기. 터미널이나 원격 접속 툴에서 명령을 내리면 Shell이 이를 해석해 Kernel에 전달하고, 실제 명령이 수행됨.

**Shell의 기능**

1. 명령어 해석
2. 프로그래밍
3. 사용자 환경 설정
    - Shell은 사용자 환경을 설정할 수 있도록 초기화 파일을 제공함.
    - 전체 설정 파일을 읽은 후 사용자 환경 설정을 읽어 사용자별로 환경을 구성.

**Shell에 표시되는 문자열 - 프롬프트**

- `사용자이름@호스트이름(컴퓨터이름): ~$`
- 슈퍼 사용자는 `$` 대신 `#`이 표시됨.

로그인 시 표시되는 Shell을 로그인 쉘이라고 함.

현재 사용 중인 Shell을 확인하는 명령어: `echo $SHELL`.

Shell 종류에 따라 프롬프트가 달라질 수 있음.

`~`는 사용자의 홈 디렉토리를 의미함.

### 명령어 입력 시 에러가 발생할 경우 대처 방법

1. 키보드 입력이 안 되는 경우: `CTRL + S`를 눌러 화면 잠금을 한 경우일 수 있음. `CTRL + Q`를 눌러 잠금을 해제.
2. 명령이 종료되지 않는 경우: `CTRL + C`를 눌러 현재 수행 중인 프로세스를 강제로 중지해야 함.
3. 텍스트 파일이 아닌 파일을 열었을 때 한글이 깨지는 경우: `CTRL + L`(clear 명령)을 눌러 화면을 클리어.

### 명령어의 구조: 명령 [옵션][인자]

- 명령: 실행 프로그램 또는 내장 명령어.
- 옵션: - 또는 -- 와 같이 입력.
    - `-` 다음에는 한 글자.
    - `--` 다음에는 단어.
    - 옵션은 대부분 순서에 상관없이 여러 개 입력 가능.
    - 한 글자인 경우 결합이 가능.

### 명령어 자동 완성

- 입력한 단어로 시작하는 명령이 하나만 존재할 경우, Tab을 누르면 자동 완성됨.
- 입력한 단어로 시작하는 명령어가 여러 개일 경우, Tab을 두 번 누르면 모든 명령어가 출력됨.

### 명령어 입력 방식

- 직접 입력.
- 텍스트 파일에 명령어를 작성해 두고, 이 파일의 내용을 읽어 수행하는 스크립트 방식 사용 가능. 파일 확장자는 .sh.
    - 작업할 때는 직접 입력하기보다는 스크립트를 작성한 후 작업하는 것이 더 안전함.

### 히스토리 기능

- 이전에 수행했던 명령어를 저장함. 위 화살표(`CTRL + P`)나 아래 화살표(`CTRL + N`)를 이용해 이전에 수행한 명령어를 확인할 수 있음.
- `CTRL + R`을 이용하면 증분 모드로 검색 가능.
    - 실패했던 명령어라도 검색 가능.
    - 명령어 형태에 부합하지 않으면 검색 불가.
- `history`를 입력하면 수행한 모든 명령어가 출력됨.
- 히스토리 옵션:
    - `!`: 직전 명령어 수행.
    - `! 번호`: 번호에 해당하는 명령어 수행.
    - `! 문자열`: 문자열로 시작하는 마지막 명령어 수행.
    - `history -d 라인번호`: 라인번호에 해당하는 명령어 삭제.
    - `history -c`: 모든 명령어 삭제.
- 히스토리 내용은 홈 디렉토리의 `.bash_history` 파일에 저장됨.
- 히스토리 저장: `history > (파일명.확장자)`.

### 명령어 도움말

- `--help` 옵션을 사용해 도움말 확인 가능.
- `man` 명령어를 사용해 도움말을 출력 가능.
    - 예: `man ls`.
- Shell이 명령어를 찾는 위치는 `환경변수 PATH`에 설정됨.
- 현재 디렉토리에서 명령어를 찾지 못하면 `PATH`에서 찾고, 그래도 없으면 Shell 내장 명령을 수행함.
    - `echo $PATH`로 확인 가능.

### 명령어의 절대 경로 찾기: `whereis [옵션] [명령어 - 실행(바이너리) 파일]`

스케줄링 작업 시 절대 경로를 기반으로 수행됨.

내장 명령의 경우 문제가 없지만, 내장 명령이 아닌 경우 절대 경로를 알아야 함.

옵션:

- `-b`: 바이너리 파일만 검색.
- `-m`: 매뉴얼 파일만 검색.
- `-s`: 소스 파일만 검색.

### `which` 명령어: `PATH`에서만 명령어를 검색

옵션:

- `-a`: 모든 경로 출력.
- `-i`: 설정 환경 출력.

| **특징** | **which** | **whereis** |
| --- | --- | --- |
| **기능** | 명령어의 실행 파일 위치를 찾음 | 실행 파일, 소스 파일, 매뉴얼 페이지 등의 위치를 모두 찾음 |
| **검색 대상** | `PATH` 환경 변수에 지정된 디렉터리 내에서 검색 | 미리 구축된 데이터베이스를 사용하여 여러 위치를 검색 |
| **결과** | 명령어의 경로(실행 가능한 파일 경로)만 출력 | 실행 파일, 소스 코드, 매뉴얼 페이지 등과 관련된 경로를 모두 출력 |
| **사용 예시** | `which gcc` -> `/usr/bin/gcc` | `whereis gcc` -> `gcc: /usr/bin/gcc /usr/lib/gcc ...` |
| **사용 목적** | 명령어가 어느 경로에서 실행될지 확인할 때 사용 | 프로그램과 관련된 모든 파일(실행 파일, 소스, 매뉴얼 등)을 찾을 때 사용 |
| **속도** | 일반적으로 빠름 (`PATH` 내에서만 검색) | 상대적으로 느릴 수 있음 (여러 위치를 검색) |

### 기타 명령어

- `passwd`: 비밀번호 변경.
- `exit`: 터미널 종료. 현재 사용 중인 Shell을 종료함.
    - 로그인 Shell에서 다른 Shell을 실행한 경우, 이전에 실행한 Shell로 이동됨.
- `clear`: 현재 화면 삭제. `CTRL + L`과 동일.

    
## 참고 자료
- 

## 배운 점 & 느낀 점
- 이번에 NoSQL 데이터베이스 중 하나인 MongoDB를 학습했습니다. 처음에는 NoSQL의 용어와 문법이 낯설었지만, 여러 가지 예제를 반복해서 입력해보니 금방 익힐 수 있었습니다. 이번 주말에 시간이 된다면, 크롤링한 데이터를 MongoDB에 삽입하는 프로그램을 작성해보고 싶습니다.

## 내일의 목표
- 한 주 동안 배운 내용을 총정리하고, 부족한 부분에 대해 보완하며 공부할 예정입니다.